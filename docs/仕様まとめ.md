# 拡張 Markdown 記法+git 管理のチェックリスト mdck（Markdown check list）

## 主要機能

- ファイル拡張子は.md のまま
- テンプレートは、別ファイルからのインポートが可能。使う際は共通コンポーネントの実態をインポートして生成 →DRY なテンプレート
- Markdown を拡張しタグ`<Tag />`により機能追加
- Parser, Linter によりエラーチェック、整合性管理
- テンプレート/チェック項目更新 → テンプレート ID、チェック項目 ID に基づき、そのテンプレートを使用しているチェックリストを一括更新
- Result タグで結果も一元管理、結果タグ内のテキストがなければ warning 検出
- .mdck/config.yml に基づき Lint エラーなどのチェック項目カスタマイズが可能
- CLI からチェックやテンプレート更新反映が可能

## ライブラリ構成

- @mdck/
  - parser パースしてエラーチェック、キャッシュに吐き出し
  - vscode-ext シンタックス、ショートカット、パース、エディタ UI、キャッシュ読み込みで ID やタグの入力補完
  - cli CICD、チェック実行

## 機能

- Markdown のエコシステムに乗るためユーザーフレンドリー（使用者は単にチェックリストとして使えば良く、自由かつ高度なカスタマイズが可能に）
- テンプレートのチェックリストの Markdown ファイルを single source of truth にしつつ、実行する際は実行結果を管理可能
- 結果欄を加えることで、チェックするだけでないチェックリストにしたい。
- Template id の変更は、git staging の段階でチェックをかけて、変更はエラーとして検出：CICD パイプラインに組み込む

### パーサーの対象となる構文

- Template タグについて、ファイル内に複数入れたり、入れ子にしたり共通コンポーネント化したい。
- Markdown の !INCLUDE 的ツール（md-include, mdx など）で断片を合成したい。
  テンプレートとインスタンスという意味で、テンプレート側は共通コンポーネントみたいな感じインポートするだけでよくて、インスタンス（使う側）は、共通コンポーネントも全て生成される、みたいな感じにしたいです。
  →Dont repeat yourself
- 命名規則について、Template、Tag、Resultなど、大文字で始めます。
- JSX構文のようなイメージで<Tag />のように、1つのタグで閉じるような書き方が原則です。

例：

```

<Template id="parent">
  <Template id="child1" src="./child1.md" />
  <Template id="child2" src="./child2.md" />
  <Template id="common" src="./common.md" />
</Template>
```

### 静的チェック

- tag の id に基づき、Template との静的差分検知（差が出ても許容されることもある）
- テンプレート/項目の削除・非互換変更時の挙動
  - テンプレートや項目 ID の削除・リネーム時に、既存チェックリストへの影響・警告方針
    - 削除された ID を参照しているチェックリストの自動修正 or warning
    - 非互換変更（breaking change）の通知・レビュー支援

```

<Template id="server-maintenance">
  # 見出し
  通常のMarkdown。チェック等は無視される。テンプレート上のMarkdownから使用するためのチェックリスト生成する際は、そのままコピーされる
  - [ ] チェック項目 <Tag itemId="1" />

  1. [ ] 番号付きチェック項目 <Tag itemId="2" isResultRequired />
  結果欄が必須
  <Result>
  # チェック結果

  </Result>
  1. [ ] 番号付きチェック項目
  使用者は、タグ無しで、自由にカスタム項目を追加可能。使用者が追加した項目は
  Parser で検出できるようにする（オプションとして、warnings
  を出したいかもしれないので）
</Template>
```

- テンプレート・参照の循環検出
  入れ子・外部参照時の循環参照検出（例：A→B→A）→ 無限展開防止のため、パーサーで検出・エラー化が必要。

### VSCode 拡張機能

- VSCODE 拡張で、ID とかをキャッシュしておいて、入力補完できるといいですよね。VSCODE では開いてるプロジェクトのルートの.mdck/.cache とかにキャッシュしたデータを読んだ上で補完する。

## 優先順位の低い機能

### エクスポート機能

- 将来的な機能として Markdown から PDF にするなどの機能が想定されます。
  - 別フォーマット変換は、タグ部分を React コンポーネントとしてレンダリングすれば HTML 化し、HTML を PDF 化すれば良いと考えます。
  - なお別に React は必須じゃなく、レンダリングが万が一必要な時のオプションみたいなイメージです。

## 不採用の機能

### ① テンプレート・項目のバージョン管理は複雑化するため作らない

もしバージョン管理したければ、新しい id で作ればいい。Template_2024 など
テンプレート/項目のバージョン属性（semver 等）を持たせる
参照側が特定バージョン指定

### ② ローカライズ、i18n も考慮しない

id を増やせばいい。

### ③AST などのパーサーの複雑化はしない

AST 不要の理由と実現方法

1. なぜ AST が不要か
   - markdown-it のトークン列は、Markdown の構造（ブロック・インライン・HTML タグ・入れ子）を十分に表現できる。
   - トークンには type（例: html_block, html_inline, list_item_open）、nesting（1:開始, 0:自己終了, -1:終了）、content（タグやテキスト本体）、attrs（属性値）などが含まれ、構造解析や属性抽出が容易。
   - AST（抽象構文木）を構築しなくても、トークン配列を線形に走査・加工するだけで、ほとんどの静的検証・テンプレート展開・入れ子展開が実現できる。
   - メリット
     - 実装がシンプル（AST 構築・再帰処理・ツリー操作が不要）
     - パフォーマンスが高い（配列走査のみ、メモリ消費も小さい）
     - markdown-it のプラグイン生態系や既存のレンダラーと親和性が高い

2. テンプレートの入れ子・外部インポートも対応可能
   - 入れ子テンプレート
     `<Template id="parent">`の中に`<Template id="child" />`のような参照タグがあれば、トークン列上で「参照トークン」を検出し、対応する定義テンプレートのトークン列に置換・展開するだけで OK。
     展開は深さ優先の再帰で実装でき、循環参照もトークン列の ID 履歴で検出可能。
   - 外部ファイルからのインポート
     参照トークン（例: `<Template id="common" src="./common.md" />`）を検出したら、src 属性で指定されたファイルを事前にパースし、トークン列を取得。
     そのトークン列を参照箇所に splice（差し込み）すれば、AST を経由せずにファイル横断のテンプレート合成ができる。

#### 具体的な流れ

1. すべてのテンプレート定義（同一ファイル＋外部ファイル）を id→ トークン列の辞書として収集
2. 参照トークンを見つけたら、該当 id のトークン列で置換
3. 置換後のトークン列に対して、Tag や Result の検証・展開を実施

トークン列ベースの展開・検証例：
- 定義収集: html_block トークンで`<Template id="...">`を検出し、nesting===1 から nesting===-1 までを id ごとに保存
- 参照展開: html_inline や html_block で`<Template id="..."/>`や`src="..."`を検出し、該当 id のトークン列で置換
- 外部ファイル: src 属性があれば、そのファイルを読み込んで同様にトークン列を取得・展開
- 循環参照検出: 展開時に id 履歴を持ち、同じ id が再度現れたらエラー
- Tag/Result 検証: 展開後のトークン列を走査し、Tag や Result の有無・属性を検証

サンプル（TypeScript 擬似コード）

```

// 1. 定義収集
const defs = collectTemplateDefinitions(tokens, externalFiles);

// 2. 展開
const expanded = expandTemplate("parent", defs, []); // []は id 履歴

// 3. 静的検証
lintTokens(expanded);

```

参考：トークンの主なプロパティ

| プロパティ | 内容例 |
| ---------- | -------------------------------------------------- |
| type       | 'html_block', 'html_inline', 'list_item_open' など |
| tag        | 'Template', 'Tag', 'Result' など |
| nesting    | 1:開始, 0:自己終了, -1:終了 |
| content    | タグやテキスト本体 |
| attrs      | [['id', 'common'], ['src', './common.md']] など |

まとめ
AST を使わなくても、markdown-it のトークン列だけでテンプレートの入れ子・外部インポート・静的検証は十分実現できる。
トークン列の線形走査＋置換・展開・検証の組み合わせで、複雑な構造もシンプルに扱える。
必要になった時だけ AST 化やツリー構造を導入すればよく、最初はトークン列ベースで始めるのが最も実装・保守コストが低い。
